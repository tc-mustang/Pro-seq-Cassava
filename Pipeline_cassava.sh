#====================
#PRO-seq shell script
#Modified for working on cassava libraries
#Lis lab pipeline
#Ver. 2.0	     
#====================

#==========================================================================================================================================

#Dependencies:					      
#1. Your FASTq, rDNA (bt2), Combinedgenome (cat spike-in and genome of interest; bt2) *bt2 build can be generated by doing "bowtie2-build infile outfile"*  				      
#2. fastx_tools					      
#3. bowtie2					      
#4. Samtools
#5. BEDTools				              

#===========================================================================================================================================

#Usage
#1. Input file path of necessary files and scripts
#2. Run the script by "sh SCRIPTPATH"

#===========================================================================================================================================

#Input
fastq="
/home/NVME/Pro-seq/Second/PIPELINE/old_trimmed.fastq.gz
/home/NVME/Pro-seq/Second/PIPELINE/white_trimmed.fastq.gz
"
genome="/home/NVME/Pro-seq/DB/Mesculenta_305_v6"
chloroplast_genome="/home/NVME/Pro-seq/DB/Chloroplast_genome"

chrominfo="/home/NVME/Pro-seq/DB/Cassava_chromsizes.txt"
nmer="36"

for file in ${fastq}
do

gunzip ${file}
echo ${file} clipping...

#Takes _q.temp file and clips any residual 3'adapter sequence which could be all or part of TGGAATTCTCGGGTGCCAAGG and generated anothe temporary file called _c.tmp
fastx_clipper -i ${file%%.*}.fastq -o _c.tmp -a TGGAATTCTCGGGTGCCAAGG -l 15

echo returning ReadLength distribution data ...
cat _c.tmp | awk '{if(NR%4==2) print length($1)}' > ${file%%.*}_clipLength.txt
cat ${file%%.*}_clipLength.txt | sort -n | uniq -c | awk '{print $2 " " $1}' > ${file%%.*}_clipLengthCounts.txt
rm ${file%%.*}_clipLength.txt

echo ${file} trimming...

#Takes _c.tmp file and trims sequences to set number of bases.
fastx_trimmer -l ${nmer} -i _c.tmp -o _c1.tmp
rm _c.tmp

echo ${file} reverse complementing...
#Takes the _c1.tmp file and flips the read because the illumnia sequences the DNA from 5'end so the adapters in PRO-seq is reversed.
fastx_reverse_complement -i _c1.tmp -o _3.tmp

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# align reads to choloroplast genome (cassava) -> filter low quality -> remove multimappers (sed code deletes all lines with 'XS:' pattern) -> return bam
echo ${file} aligning to combined genome...
bowtie2 --end-to-end --sensitive -x $chloroplast_genome -U _3.tmp --un _4.tmp -p 11 | awk '$2 != 4 {print}' | sed '/XS:/d' |  samtools view -bS '-' > ${file%%.*}_Chloroplast.bam
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# align reads to casava genome -> filter low quality -> remove multimappers (sed code deletes all lines with 'XS:' pattern) -> return bam
echo ${file} aligning to combined genome...
bowtie2 --end-to-end --sensitive -x $genome -U _4.tmp -p 11 | awk '$2 != 4 {print}' | sed '/XS:/d' | samtools view -bS '-' > ${file%%.*}.bam
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

rm *.tmp
echo ${file%%.*} converting BAM to BED...
bamToBed -i ${file%%.*}.bam > ${file%%.*}.bed

echo indexing bam
samtools sort ${file%%.*}.bam ${file%%.*}_sorted
samtools index ${file%%.*}_sorted.bam ${file%%.*}_sorted.bai 
rm ${file%%.*}.bam

#Converts BED to Sorted Bed using command line arguments
#sorts by chromosome
#Bedgraph file shows how many reads are present in each base position/
echo Sorting BED...
sort -k 1,1 -k2,2n ${file%%.*}.bed > ${file%%.*}_sorted.bed
rm ${file%%.*}.bed


echo Number of reads mapping to cassava genome:
wc -l ${file%%.*}_sorted.bed

#Generate non-nomalized Bedgraphs
echo Generating non-normalized Bedgraphs...
awk '$6 == "+"' ${file%%.*}_sorted.bed | genomeCoverageBed -i stdin -3 -bg -g $chrominfo > ${file%%.*}_plus.bedgraph 
awk '$6 == "-"' ${file%%.*}_sorted.bed | genomeCoverageBed -i stdin -3 -bg -g $chrominfo > ${file%%.*}_m.bedgraph
awk '{$4=$4*-1; print}' ${file%%.*}_m.bedgraph > ${file%%.*}_minus.bedgraph

echo Normalizing bedgraphs
a=$(awk '{ sum += $4 } END { print sum }' ${file%%.*}_plus.bedgraph )
b=$(awk '{ sum += $4 } END { print sum }' ${file%%.*}_minus.bedgraph )
d=$(($b*-1))
c=$(expr $a + $d)

echo $c | awk '{ c="'$c'"; printf "%s\t%s\t%s\t%s\n", $1, $2, $3, ($4*1000000)/c}' ${file%%.*}_plus.bedgraph  > ${file%%.*}_normed_plus.bedgraph
echo $c | awk '{ c="'$c'"; printf "%s\t%s\t%s\t%s\n", $1, $2, $3, ($4*1000000)/c}' ${file%%.*}_minus.bedgraph  > ${file%%.*}_normed_minus.bedgraph

#Make BigWig
echo Making BigWigs...
bedGraphToBigWig ${file%%.*}_plus.bedgraph $chrominfo ${file%%.*}_plus.bw
bedGraphToBigWig  ${file%%.*}_minus.bedgraph $chrominfo ${file%%.*}_minus.bw
bedGraphToBigWig  ${file%%.*}_normed_plus.bedgraph $chrominfo ${file%%.*}_normed_plus.bw
bedGraphToBigWig  ${file%%.*}_normed_minus.bedgraph $chrominfo ${file%%.*}_normed_minus.bw

#rm *.tmp
rm ${file%%.*}_m.bedgraph
gzip *.bed
gzip ${file%%.*}.fastq

done


## check for existence of subdirectories, make if non-existant 
if [ ! -d "./bed" ]; then 
mkdir "./bed"
fi
if [ ! -d "./bedgraph" ]; then 
mkdir "./bedgraph"
fi
if [ ! -d "./logs" ]; then 
mkdir "./logs"
fi
if [ ! -d "./bw" ]; then 
mkdir "./bw"
fi
if [ ! -d "./bw" ]; then 
mkdir "./bw"
fi
if [ ! -d "./bam" ]; then 
mkdir "./bam"
fi

## Move aligned files to corresponding directories
mv *.bed.gz ./bed 
mv *.bw ./bw
mv *.bedgraph ./bedgraph 
mv *.txt ./logs 
mv *.bam* ./bam
mv *.bai ./bam